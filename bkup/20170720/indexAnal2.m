
% Called from: groupAnalysisController.m
% Dependencies: groupAnalysisParams.m, findCross.m
% Also depends on files generated by: makeParPlot.m, makeGroupPlot.m

clearvars -except pValues kSize cutOff rValues ampClust groupNum

% load parameters
groupAnalysisParams

% Which type of run to analyze
analType = 'darts_dartRival'; %'darts'

% Exclude outliers (pars > 2STDs of EEG freq) ?
excludeOutlierIndivs = 1;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sets up the following matrix for index analysis:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Column 1: Dominance proportion
% Column 2: Dominant epoch durations
% Column 3: Mixed epoch durations
% Column 4: Number of transitions
% Column 5: Number of switches
% Column 6: Hertz
% Column 7: HertzMedian
% Column 8: HertzTrans
% Column 9: HertzTransMedian
% Column 10: HertzTransNoRevsMedian
% Column 11: HertzTransNoRevsMean
% Column 12: dartRival period
% Column 13: Dom State length (Calculated from EEG transitions)
% Column 14: peak to trough period calculated from transition
% Column 15: peak to trough amplitude calculated from transition
% Column 16: latency (time between cross and reported transition) 
% Column 17: oscillation rate calculated by taking fft of H-L
% Column 18: oscillation rate of SIM trials 
% Column 19: SNR of low IM frequency
% Column 20: SNR of high IM frequency 
% Column 21: low interquartile prop
% Column 22: high interquartile prop
% Column 23: H-L interquartile prop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% behavioral indices
C{1} = 'domProp';
C{2} = 'domDur';
C{3} = 'mixedDur';
C{4} = 'numTrans';
C{5} = 'numSwitches';
C{6} = 'Hertz';
C{7} = 'HertzMedian';
C{8} = 'HertzTrans';
C{9} = 'HertzTransMedian';
C{10} = 'HertzTransNoRevsMedian';
C{11} = 'HertzTransNoRevsMean';

% EEG metrics
C{12} = 'period';
C{13} = 'domDurEEG';
C{14} = 'ptPd';
C{15} = 'ptAmp';
C{16} = 'latency';
C{17} = 'oscFreq';
C{18} = 'simOscFreq';
C{19} = 'lowIMsnr';
C{20} = 'hiIMsnr';
C{21} = 'loInterQprop';
C{22} = 'hiInterQprop';
C{23} = 'h-lInterQprop';

labels{1} = 'Proportion of perceptual suppression';
labels{2} = 'Dominant state duration (s)';
labels{3} = 'Mixed state duration (s)';
labels{4} = 'Transitions / trial';
labels{5} = 'Switches / trial';
labels{16} = 'Latencies (s)';
labels{17} = 'Oscillation frequency (Hz)';
labels{18} = 'SIM Oscillation frequency (Hz)';
labels{19} = 'low IM SNR';
labels{20} = 'high IM SNR';
labels{21} = 'low frequency interquartile proportion';
labels{22} = 'high frequency interquartile proportion';
labels{23} = 'high minus low interquartile proportion';

analMatrix{1} = [];
analMatrix{2} = [];
ampMatrix = [];
idVect = [];

for iGroup = 1:length(groupParNums)
    for parNum = groupParNums{iGroup}
        numFormat = '%02d';
        parName = [groupCodes{iGroup} num2str(parNum, numFormat)];
        analRow = nan(1, 23);
        
        % get participant files
        parFiles = dir([bResultsDir parName '*']);
        
        %% get behavioral indices
        
        % dominance proportion
        if exist([bResultsDir parName '_' analType '_propDom.txt'], 'file')
            analRow(1) = load([bResultsDir parName '_' analType '_propDom.txt']);
        else
            continue; % if participant does not have propDom file, they are not in the study
        end
        
        % avg dominant epoch duration
        if exist([bResultsDir parName '_' analType '_StateDurs.txt'],'file')
            analRow(2) = load([bResultsDir parName '_' analType '_StateDurs.txt']);
        end
        
        % avg mixed epoch duration
        if exist([bResultsDir parName '_' analType '_UpDurs.txt'],'file')
            analRow(3) = load([bResultsDir parName '_' analType '_UpDurs.txt']);
        end
        
        % Num transitions
        if exist([bResultsDir parName '_' analType '_Transitions.txt'],'file')
            analRow(4) = load([bResultsDir parName '_' analType '_Transitions.txt']);
             % Limit number of transitions (for purpose of fft analysis)
        end
        
        % Num switches
        if exist([bResultsDir parName '_' analType '_Switches.txt'],'file')
            analRow(5) = load([bResultsDir parName '_' analType '_Switches.txt']);
            % Limit number of switches (for purpose of fft analysis)
            %if analRow(5) < 3 % for FFT analysis, minimum switch rate
               % analRow(5) = NaN;
            %end
        end
        
        % Hertz
        if exist([bResultsDir parName '_' analType '_Hertz.txt'],'file')
            analRow(6) = load([bResultsDir parName '_' analType '_Hertz.txt']);
        end
        
        % HertzMedian
        if exist([bResultsDir parName '_' analType '_HertzMedian.txt'],'file')
            analRow(7) = load([bResultsDir parName '_' analType '_HertzMedian.txt']);
        end
        
        % HertzTrans
        if exist([bResultsDir parName '_' analType '_HertzTrans.txt'],'file')
            analRow(8) = load([bResultsDir parName '_' analType '_HertzTrans.txt']);
        end
        
        % HertzTransMedian
        if exist([bResultsDir parName '_' analType '_HertzTransMedian.txt'],'file')
            analRow(9) = load([bResultsDir parName '_' analType '_HertzTransMedian.txt']);
        end
        
         % HertzTransNoRevsMedian
        if exist([bResultsDir parName '_' analType '_HertzTransNoRevsMedian.txt'],'file')
            analRow(10) = load([bResultsDir parName '_' analType '_HertzTransNoRevsMedian.txt']);
        end
        
         % HertzTransNoRevsMean
        if exist([bResultsDir parName '_' analType '_HertzTransNoRevsMean.txt'],'file')
            analRow(11) = load([bResultsDir parName '_' analType '_HertzTransNoRevsMean.txt']);
        end
        
         % store participant's study ID
        idVect = [idVect; parNum];
        
        %% EEG data: get periods and amps from transition plots 
        
        Pds = nan(1, 6); % 1 & 2 dartRival (h2l, l2h), 5 & 6 marzRival (3 & 4 blank)
        
        % load averaged, normalized transitions for the participant
        % note that these are saved in makeGroupPlot.m
        if exist(['transitions/finalTransitions_norm/' parName '_' normType '.mat'], 'file')
            load(['transitions/finalTransitions_norm/' parName '_' normType '.mat'])
        else
            continue;
        end
        tLists = ntLists;
        
        if strcmp(analType, 'darts_dartRival')
            tTypes = [1 2];
        else
            tTypes = [5 6]; % marz
        end
        
        % space to store indices before averaging (this is moot since we are
        % averaging transitions before caclulating the period...just leaving this here
        % in case we decide to change it) 
        allPds = []; % period (measured using crossing points)
        domStates = []; % half period (measured using crossing points)
        ptPds = []; % periods measured peak to trough
        ptAmps = []; % amplitudes measured peak to trough
        ptRatio = [];
        lats = []; % latencies
        
        for tType = tTypes
            if ~isempty(tLists{tType})
                
                % average transitions before calculating period
                tLists{tType}.f1 = nanmean(tLists{tType}.f1, 1);
                tLists{tType}.f2 = nanmean(tLists{tType}.f2, 1);
                
                for t = 1:size(tLists{tType}.f1,1)
                    
                    f1trace = tLists{tType}.f1(t,:);
                    f2trace = tLists{tType}.f2(t,:);
                    
                    
                    % Demean transitions (in case not already demeaned)
                    f1trace = f1trace - nanmean(f1trace);
                    f2trace = f2trace - nanmean(f2trace);
                    
                    % Find crosses between frequency traces corresponding
                    % to the beginning and end of the transition
                    
                    % First find potential transition crosses
                    [leftCross, leftDist] = findCross(f1trace, f2trace, buttonPress, 'left');
                    [rightCross, rightDist] = findCross(f1trace, f2trace, buttonPress, 'right');
                    
                    slopeInt = 50; % interval for determining pos vs neg slope
                    
                    % Use slope and type of transition to identify the
                    % transition cross
                    if isnan(leftCross) || leftCross <= slopeInt
                        transCross = rightCross;
                        leftEnd = leftCross;
                        rightEnd = findCross(f1trace, f2trace, transCross, 'right');
                    elseif isnan(rightCross) || rightCross >= length(f1trace) - slopeInt
                        transCross = leftCross;
                        rightEnd = rightCross;
                        [leftEnd, ~] = findCross(f1trace, f2trace, transCross, 'left');
                    else                       
                        % check in higher frequency (generally has larger dynamic range)
                        f2leftDiff = f2trace(leftCross - slopeInt) - f2trace(leftCross + slopeInt);
                        f2rightDiff = f2trace(rightCross - slopeInt) - f2trace(rightCross + slopeInt);
                        
                        if tType == 1
                            if f2leftDiff <= f2rightDiff
                                transCross = leftCross;
                                rightEnd = rightCross;
                                [leftEnd, ~] = findCross(f1trace, f2trace, transCross, 'left');
                            else
                                transCross = rightCross;
                                leftEnd = leftCross;
                                rightEnd = findCross(f1trace, f2trace, transCross, 'right');
                            end
                        elseif tType == 2
                            if f2leftDiff >= f2rightDiff
                                transCross = leftCross;
                                rightEnd = rightCross;
                                [leftEnd, ~] = findCross(f1trace, f2trace, transCross, 'left');
                            else
                                transCross = rightCross;
                                leftEnd = leftCross;
                                rightEnd = findCross(f1trace, f2trace, transCross, 'right');
                            end
                        end
                    end
                    
                    % store latency
                    lats = [lats buttonPress - transCross];
                        
                    % store period
                    Pds(tType) = rightEnd - leftEnd;
                    allPds = [allPds Pds(tType)];
                    
                    % store domState length
                    domStates = [domStates rightEnd - transCross transCross - leftEnd];
                    
                    % calculate peak-to-trough period
                    
                    % set range to look for peak / trough
                    if isnan(leftEnd)
                        leftEnd = 1;
                    end
                    if isnan(rightEnd)
                        rightEnd = length(f1trace);
                    end
                    
                    if tType == 1
                        [~, f1PeakI] = nanmax(f1trace(leftEnd:transCross));
                        f1PeakI = f1PeakI - 1 + leftEnd;
                        [~, f1TroughI] = nanmin(f1trace(transCross:rightEnd));
                        f1TroughI = f1TroughI - 1 + transCross;
                        [~, f2PeakI] = nanmax(f2trace(transCross:rightEnd));
                        f2PeakI = f2PeakI - 1 + transCross;
                        [~, f2TroughI] = nanmin(f2trace(leftEnd:transCross));
                        f2TroughI = f2TroughI - 1 + leftEnd;
                        
                    else
                        [~, f1PeakI] = nanmax(f1trace(transCross:rightEnd));
                        f1PeakI = f1PeakI - 1 + transCross;
                        [~, f1TroughI] = nanmin(f1trace(leftEnd:transCross));
                        f1TroughI = f1TroughI - 1 + leftEnd;
                        [~, f2PeakI] = nanmax(f2trace(leftEnd:transCross));
                        f2PeakI = f2PeakI - 1 + leftEnd;
                        [~, f2TroughI] = nanmin(f2trace(transCross:rightEnd));
                        f2TroughI = f2TroughI - 1 + transCross;
                        
                    end

                    % Plot traces with peaks and troughs marked, for
                    % debugging
                    % if iGroup == 2
                    %     figure;
                    %     plot(f1trace)
                    %     hold on
                    %     plot(f2trace)
                    %     plot(f1PeakI, f1trace(f1PeakI), 'ro');
                    %     plot(f1TroughI, f1trace(f1TroughI), 'ro');
                    %     plot(f2PeakI, f2trace(f2PeakI), 'bo');
                    %     plot(f2TroughI, f2trace(f2TroughI), 'bo');
                    %     hold off
                    % end
                    
                    ptPds = [ptPds abs(f1PeakI - f1TroughI) abs(f2PeakI - f2TroughI)];
                    ptAmps = [ptAmps f2trace(f2PeakI) - f2trace(f2TroughI) f1trace(f1PeakI) - f1trace(f1TroughI)];
                end
            end
        end
        
        % average and convert to seconds
        analRow(12) = nanmean(allPds)/sampRate;
        analRow(13) = nanmean(domStates)/sampRate;
        analRow(14) = nanmean(ptPds)/sampRate;
        analRow(15) = nanmean(ptAmps);
        analRow(16) = nanmean(lats)/sampRate;
        
        %% get oscillation frequencies
        
        if exist([indicesDir 'rateFreqs/' parName '.mat'], 'file')
            load([indicesDir 'rateFreqs/' parName '.mat']);
            analRow(17) = oscFreq;
            %if analRow(5) < 3 % for FFT analysis, minimum switch rate
                %analRow(17) = NaN;
            %end
        end
        
        if exist([indicesDir 'rateFreqs/' parName '_SIM.mat'], 'file')
            load([indicesDir 'rateFreqs/' parName '_SIM.mat']);
            analRow(18) = oscFreq;
            %if analRow(5) < 3 % for FFT analysis, minimum switch rate
                %analRow(17) = NaN;
            %end
        end       
        
        %% get SNRs of IM frequencies
        
        if exist([indicesDir 'imSNRs/' parName '.mat'], 'file')
            load([indicesDir 'imSNRs/' parName '.mat']);
            analRow(19) = lowSNR;
            analRow(20) = highSNR;
        end
        
        %% get interQuartile proportions
        
        if exist([indicesDir 'interQprop/' parName '.mat'], 'file')
            load([indicesDir 'interQprop/' parName '.mat']);
            analRow(21) = meanf1Ratio;
            analRow(22) = meanf2Ratio;
            analRow(23) = meanHmLRatio;
        end
        
        analMatrix{iGroup} = [analMatrix{iGroup}; analRow];
    end
    
%     % calculate correlation coefficients
%     %[R{iGroup}, P{iGroup}] = corrcoef(analMatrix{iGroup}, 'rows', 'pairwise'); % pearson's coefficient
%     [R{iGroup}, P{iGroup}] = corr(analMatrix{iGroup}, 'type','spearman', 'rows', 'pairwise');    
    
    % save full analysis matrices
    currMatrix = analMatrix{iGroup};
    if strcmp(analType, 'darts')
        save(['indices/' analGroupIDs{iGroup} 'darts_analMatrix2', 'currMatrix']);
    else
        save(['indices/' analGroupIDs{iGroup} 'marz_analMatrix2', 'currMatrix']);
    end    
end



%% exclude outliers (pars > 2STDs of EEG freq)
if excludeOutlierIndivs == 1
    meanC = nanmean(analMatrix{1,1}(:,17)); 
    meanA = nanmean(analMatrix{1,2}(:,17));
    stdC = nanstd(analMatrix{1,1}(:,17)); 
    stdA = nanstd(analMatrix{1,2}(:,17));

    outC = union(find((analMatrix{1,1}(:,17) < meanC - 2*stdC)),find((analMatrix{1,1}(:,17) > meanC + 2*stdC)));
    outA = union(find((analMatrix{1,2}(:,17) < meanA - 2*stdA)),find((analMatrix{1,2}(:,17) > meanA + 2*stdA)));

    analMatrix{1,1}(outC,17) = NaN;
    analMatrix{1,2}(outA,17) = NaN;
end

%% Calculate correlation coefficients
for iGroup = 1:length(groupParNums)
    [R{iGroup}, P{iGroup}] = corr(analMatrix{iGroup}, 'type','spearman', 'rows', 'pairwise');
end

%% plot potential correlations (Both groups on one plot)
colors = [colorC; colorA];
   
for i = [5] %[2 4:5] %size(fullAnalMatrix, 2)
    for j = [17]; %[12:17] %i+1:size(fullAnalMatrix,2)
        figure
        hold on
        for iGroup = 1:length(groupParNums)
            %if abs(P(i,j)) < 0.1
            pl{iGroup} = plot(analMatrix{iGroup}(:,i), analMatrix{iGroup}(:,j), 'o', 'MarkerFaceColor', colors(iGroup,:), 'MarkerEdgeColor', colors(iGroup,:));
            validi = ~isnan(analMatrix{iGroup}(:,i));
            validj = ~isnan(analMatrix{iGroup}(:,j));
            validBoth = validi & validj;
            p = polyfit(analMatrix{iGroup}(validBoth,i),analMatrix{iGroup}(validBoth,j),1);   % p returns 2 coefficients fitting r = a_1 * x + a_2
            line = p(1) .* analMatrix{iGroup}(validBoth,i) + p(2); % compute a new vector r that has matching datapoints in x
            plot(analMatrix{iGroup}(validBoth,i), line, 'Color',colors(iGroup,:)); %axis([-1 14 0 2])
            
            xlabel([labels{i}]);
            ylabel([labels{j}]);
            %end
        end
        
        % put r- and p-values on plot
        for iGroup = 1:length(groupParNums)
            xax = xlim;
            yax = ylim;
            text(xax(1) + (xax(2) - xax(1))/20, yax(2) - (yax(2) - yax(1))*(.05*iGroup + .2),['r =' num2str(R{iGroup}(i,j)) '   p =' num2str(P{iGroup}(i,j))], 'FontSize', 10, 'Color', colors(iGroup,:))
        end
        
        legend([pl{1} pl{2}],'Controls', 'ASC')
        if j == 17 % for legend placement for oscFreq vs. numSwitches
            legend([pl{1} pl{2}],'Controls', 'ASC','Location','northwest');
        end
        box off;
        
        % save figures
        if strcmp(analType, 'darts_dartRival')
            figName = [corrPlotDir C{i} 'vs' C{j} '_DARTS.jpg'];
        else
            figName = [corrPlotDir '_' C{i} 'vs' C{j} '_MARZ.jpg'];
        end
        saveas(gcf,figName,'jpg')
    end
end

%% Correlations (one plot for each group)

for i = [5];%[5] %[2 4:5] %size(fullAnalMatrix, 2)
    for j = [17]; %[17]; %[12:17] %i+1:size(fullAnalMatrix,2)
        for iGroup = 1:length(groupParNums)
            figure
            hold on
            %if abs(P(i,j)) < 0.1
            plot(analMatrix{iGroup}(:,i), analMatrix{iGroup}(:,j), 'o', 'MarkerFaceColor', colors(iGroup,:), 'MarkerEdgeColor', colors(iGroup,:));
            validi = ~isnan(analMatrix{iGroup}(:,i));
            validj = ~isnan(analMatrix{iGroup}(:,j));
            validBoth = validi & validj;
            p = polyfit(analMatrix{iGroup}(validBoth,i),analMatrix{iGroup}(validBoth,j),1);   % p returns 2 coefficients fitting r = a_1 * x + a_2
            line = p(1) .* analMatrix{iGroup}(validBoth,i) + p(2); % compute a new vector r that has matching datapoints in x
            plot(analMatrix{iGroup}(validBoth,i), line, 'Color',colors(iGroup,:)); %axis([-1 14 0 2])
            
            xlabel([labels{i}]);
            ylabel([labels{j}]);
            %end
            
            %xlim([4 20])
            %ylim([0.16 0.3])
            
            % put r- and p-values on plot
            xax = xlim;
            yax = ylim;
            text(xax(1) + (xax(2) - xax(1))/20, yax(2) - (yax(2) - yax(1))*(.1),['r =' num2str(R{iGroup}(i,j)) '   p =' num2str(P{iGroup}(i,j))], 'FontSize', 10, 'Color', colors(iGroup,:))
            
            if iGroup == 1
                title('Controls      .')
            else
                title('ASC         .')
            end
            
            % save figure
            if strcmp(analType, 'darts_dartRival')
                figName = [corrPlotDir C{i} 'vs' C{j} '_DARTS_' analGroupIDs{iGroup} '.jpg'];
            else
                figName = [corrPlotDir '_' C{i} 'vs' C{j} '_MARZ_' analGroupIDs{iGroup} '.jpg'];
            end
            saveas(gcf,figName,'jpg')
        end
    end
end

%% Bar Graphs
for iIndex = [17]; %[1 5 16 17 18];%[17]; %[1 5 17] % 12:17
    figure;
    controlData = analMatrix{1}(:,iIndex);
    ascData = analMatrix{2}(:,iIndex);
    bar(1, nanmean(controlData), 'FaceColor', colors(1,:));
    hold on
    bar(2, nanmean(ascData), 'FaceColor', colors(2,:));
    scatter(ones(1,length(controlData)), controlData, [], colors(1,:)*0.6,'filled');
    scatter(ones(1,length(ascData))+ 1, ascData, [], colors(2,:)*0.6,'filled');
    errorbar([1 2], [nanmean(controlData) nanmean(ascData)], [ste(controlData) ste(ascData)],'k.','LineWidth',2);
    set(gca,'XTick',[1 2]);
    set(gca,'XTickLabel',{'Controls','ASC'})
    ylabel(labels{iIndex},'FontSize',20);
    box off
    
    % difference between controls and ASCs?
    [~,P] = ttest2(controlData,ascData);
    yax = ylim;
    text(1.5, yax(2) - (yax(2)-yax(1))*0.1,['p = ' num2str(P)],'FontSize', 12)
    
     % save bar graphs
        if strcmp(analType, 'darts_dartRival')
            figName = [barPlotDir C{iIndex} '_DARTS.jpg'];
        else
            figName = [barPlotDir '_' C{iIndex} '_MARZ.jpg'];
        end
        saveas(gcf,figName,'jpg')
end







